TIM_HandleTypeDef htim16;
TIM_HandleTypeDef htim17;
DMA_HandleTypeDef hdma_tim16_up;
DMA_HandleTypeDef hdma_tim17_up;

#define error(a)       {while(1) \
{\
  for(uint8_t i=0;i<a;i++) {\
    digitalWrite(D30,HIGH);\
    delay(15);\
    digitalWrite(D30,LOW);\
    delay(500);\
  }\
  delay(1000);\
  }\
}

void HAL_TIM_WS2812_MspInit(TIM_HandleTypeDef* htim_base)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  if(htim_base->Instance==TIM16)
  {
  /* USER CODE BEGIN TIM16_MspInit 0 */

  /* USER CODE END TIM16_MspInit 0 */
    /* Peripheral clock enable */

    __HAL_RCC_GPIOB_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_TIM16;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    __HAL_RCC_TIM16_CLK_ENABLE();
    /* TIM16 DMA Init */
    /* TIM16_UP Init */
    hdma_tim16_up.Instance = DMA1_Channel1;
    hdma_tim16_up.Init.Request = DMA_REQUEST_TIM16_CH1;
    hdma_tim16_up.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_tim16_up.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim16_up.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim16_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_tim16_up.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_tim16_up.Init.Mode = DMA_CIRCULAR;
    hdma_tim16_up.Init.Priority = DMA_PRIORITY_HIGH;
    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_CC1],hdma_tim16_up);
    if (HAL_DMA_Init(htim_base->hdma[TIM_DMA_ID_CC1]) != HAL_OK)
    {
      error(3);
    }
  /* USER CODE BEGIN TIM16_MspInit 1 */
    HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);

  /* USER CODE END TIM16_MspInit 1 */
  }
  else if(htim_base->Instance==TIM17)
  {
    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**TIM17 GPIO Configuration
    PB7     ------> TIM17_CH1N
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF14_TIM17;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  /* USER CODE BEGIN TIM17_MspInit 0 */

  /* USER CODE END TIM17_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM17_CLK_ENABLE();

    /* TIM17 DMA Init */
    /* TIM17_UP Init */
    hdma_tim17_up.Instance = DMA1_Channel1;
    hdma_tim17_up.Init.Request = DMA_REQUEST_TIM17_UP;
    hdma_tim17_up.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_tim17_up.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim17_up.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim17_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_tim17_up.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_tim17_up.Init.Mode = DMA_NORMAL;
    hdma_tim17_up.Init.Priority = DMA_PRIORITY_HIGH;
    if (HAL_DMA_Init(&hdma_tim17_up) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_UPDATE],hdma_tim17_up);

    HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);

  /* USER CODE BEGIN TIM17_MspInit 1 */

  /* USER CODE END TIM17_MspInit 1 */
  }
}

void WS2812B::_init(void) {
	HardwareTimer *myTim = new HardwareTimer(TIM16);
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM16_Init 1 */

  /* USER CODE END TIM16_Init 1 */
  htim16.Instance = TIM16;
  htim16.Init.Prescaler = (uint32_t)((myTim->getTimerClkFreq() / TIMER_CLOCK_FREQ) - 1);
  htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim16.Init.Period = TIMER_PERIOD - 1;
  htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim16.Init.RepetitionCounter = 0;
  htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  //HAL_TIM_Base_Init(&htim16);
  // if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
  // {
  //   error(10);
  // }
  if (HAL_TIM_PWM_Init(&htim16) != HAL_OK)
  {
    error(2)
  }

  HAL_TIM_WS2812_MspInit(&htim16);

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  // sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  // sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if(HAL_TIM_PWM_ConfigChannel(&htim16, &sConfigOC, TIM_CHANNEL_1)  != HAL_OK)
  {
    error(5);
  }
  // sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  // sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  // sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  // sBreakDeadTimeConfig.DeadTime = 0;
  // sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  // sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  // sBreakDeadTimeConfig.BreakFilter = 0;
  // sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  // HAL_TIMEx_ConfigBreakDeadTime(&htim16, &sBreakDeadTimeConfig);

  uint8_t err=HAL_TIM_PWM_Start_DMA(&htim16, TIM_CHANNEL_1, (uint32_t *) MyTempbuffer,	MyTempbufsize);
  if(err != HAL_OK)
  {
    Serial.println(err);
    error(err);
  }
}

void DMA1_Channel1_IRQHandler(void) {
	HAL_DMA_IRQHandler(htim16.hdma[TIM_DMA_ID_CC1]);
}
