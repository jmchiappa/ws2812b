TIM_HandleTypeDef htim16;
DMA_HandleTypeDef hdma_tim16_ch1;



#define error(a)       {while(1) \
{\
  for(uint8_t i=0;i<a;i++) {\
    digitalWrite(D30,HIGH);\
    delay(15);\
    digitalWrite(D30,LOW);\
    delay(500);\
  }\
  delay(1000);\
  }\
}

// void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
// {
//   if(htim_base->Instance==TIM16)
//   {
//   /* USER CODE BEGIN TIM16_MspInit 0 */

//   /* USER CODE END TIM16_MspInit 0 */
//     /* Peripheral clock enable */
//     __HAL_RCC_TIM16_CLK_ENABLE();

//     /* TIM16 DMA Init */
//     /* TIM16_CH1 Init */
//     hdma_tim16_ch1.Instance = DMA1_Channel2;
//     hdma_tim16_ch1.Init.Request = DMA_REQUEST_TIM16_CH1;
//     hdma_tim16_ch1.Init.Direction = DMA_MEMORY_TO_PERIPH;
//     hdma_tim16_ch1.Init.PeriphInc = DMA_PINC_DISABLE;
//     hdma_tim16_ch1.Init.MemInc = DMA_MINC_ENABLE;
//     hdma_tim16_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
//     hdma_tim16_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
//     hdma_tim16_ch1.Init.Mode = DMA_CIRCULAR;
//     hdma_tim16_ch1.Init.Priority = DMA_PRIORITY_LOW;
//     if (HAL_DMA_Init(&hdma_tim16_ch1) != HAL_OK)
//     {
//       Error_Handler();
//     }

//     __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_CC1],hdma_tim16_ch1);

//   /* USER CODE BEGIN TIM16_MspInit 1 */

//   /* USER CODE END TIM16_MspInit 1 */
//   }

// }

// void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
// {
//   GPIO_InitTypeDef GPIO_InitStruct = {0};
//   if(htim->Instance==TIM16)
//   {
//   /* USER CODE BEGIN TIM16_MspPostInit 0 */

//   /* USER CODE END TIM16_MspPostInit 0 */

//     __HAL_RCC_GPIOB_CLK_ENABLE();
//     /**TIM16 GPIO Configuration
//     PB8     ------> TIM16_CH1
//     */
//     GPIO_InitStruct.Pin = GPIO_PIN_8;
//     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//     GPIO_InitStruct.Pull = GPIO_NOPULL;
//     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
//     GPIO_InitStruct.Alternate = GPIO_AF14_TIM16;
//     HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

//   /* USER CODE BEGIN TIM16_MspPostInit 1 */

//   /* USER CODE END TIM16_MspPostInit 1 */
//   }

// }


void HAL_TIM_WS2812_MspInit(TIM_HandleTypeDef* _TimHandle_base)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();
  /* USER CODE BEGIN TIM16_MspInit 0 */

  /* USER CODE END TIM16_MspInit 0 */
    /* Peripheral clock enable */

    __HAL_RCC_GPIOB_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF14_TIM16;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    __HAL_RCC_TIM16_CLK_ENABLE();
    /* TIM16 DMA Init */
    /* TIM16_UP Init */
    hdma_tim.Instance = DMA1_Channel2;
    hdma_tim.Init.Request = DMA_REQUEST_TIM16_CH1;
    hdma_tim.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_tim.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_tim.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_tim.Init.Mode = DMA_CIRCULAR;
    hdma_tim.Init.Priority = DMA_PRIORITY_HIGH;
    if (HAL_DMA_Init(&hdma_tim) != HAL_OK)
    {
      error(3);
    }
    __HAL_LINKDMA(_TimHandle_base,hdma[TIM_DMA_ID_CC1],hdma_tim);
  /* USER CODE BEGIN TIM16_MspInit 1 */
  // HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
  // HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
  /* USER CODE END TIM16_MspInit 1 */

}

void WS2812B::_init(void) {
    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
	  HardwareTimer *myTim = new HardwareTimer(TIM16);

  /* USER CODE BEGIN TIM16_Init 1 */
  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel2_IRQn interrupt configuration */
  // HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
  // HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);

  /* USER CODE END TIM16_Init 1 */
  _TimHandle.Instance = TIM16;
  _TimHandle.Init.Prescaler = (uint32_t)((myTim->getTimerClkFreq() / TIMER_CLOCK_FREQ) - 1);
  _TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
  _TimHandle.Init.Period = TIMER_PERIOD - 1;
  _TimHandle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  _TimHandle.Init.RepetitionCounter = 0;
  _TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  HAL_TIM_Base_Init(&_TimHandle);
  if (HAL_TIM_Base_Init(&_TimHandle) != HAL_OK)
  {
    error(10);
  }
  if (HAL_TIM_PWM_Init(&_TimHandle) != HAL_OK)
  {
    error(2)
  }
  HAL_TIM_WS2812_MspInit(&_TimHandle);

  _sConfig.OCMode = TIM_OCMODE_PWM1;
  _sConfig.Pulse = 0;
  _sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  // _sConfig.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  _sConfig.OCFastMode = TIM_OCFAST_DISABLE;
  _sConfig.OCIdleState = TIM_OCIDLESTATE_RESET;
  _sConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if(HAL_TIM_PWM_ConfigChannel(&_TimHandle, &_sConfig, TIM_CHANNEL_1)  != HAL_OK)
  {
    error(5);
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.BreakFilter = 0;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  HAL_TIMEx_ConfigBreakDeadTime(&_TimHandle, &sBreakDeadTimeConfig);

  uint8_t err=HAL_TIM_PWM_Start_DMA(&_TimHandle, TIM_CHANNEL_1, (uint32_t *) MyTempbuffer,	MyTempbufsize);
  // if(err != HAL_OK)
  // {
  //   Serial.println(err);
  //   error(err);
  // }


  
}

// void DMA1_Channel2_IRQHandler(void) {
// 	HAL_DMA_IRQHandler(_TimHandle.hdma[TIM_DMA_ID_CC1]);
//   // ws2812_update();
// }
